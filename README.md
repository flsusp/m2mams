# m2mams - Machine to machine authentication made simple

This project aims to provide a standard mechanism for generating, storing and usage of asymetric cryptographic keys to provide safe authentication for machine to machine
communication over HTTPS. Along with this standard, it provides a simple to use command line interface (CLI) and a set of implementations.

The usage of asymetric keys is a key architectural decision on machine to machine authentication, since it is does not require secret tokens to be stored at the server side,
but just on the client side. Also the usage of HTTPS as the communication protocol makes it possible to use partial message signatures, since the protocol guarantees that
the overall message is authentic. So, the intent here is just to send within the HTTPS payload a signature that allows verifing that the user is who he says he is.

## Key Generation

The pair of assymetric keys (we are going to call it "key pair" from now on) that are going to be used for signing messages are generated at the client side. The key pair
contains two keys: a private key and a public one. The private key should be kept private at the client side and the public key can be sent to the server and it is the
key that is going to be used to verify if the messages sent to the server were generated by the known clients.

There are two ways of generating the key pairs so `m2mams` is able to use the generated keys. The first way we are going to describe here uses openssh and openssl.
The second one uses a simple command line utility to automate the same steps.

### Using Openssh + Openssl

Requirements: you need openssh and openssl installed to execute the steps bellow.

1. Creates a folder called `.m2mams` in the user home directory. This is the default name, but you can provide different names that would require some parameters that makes the
example a little bit complex for now.
1. Inside that folder, creates a folder with the name same as the UID (user identification) that is going to identify the user at the server side. This usually is an email address
or just a username.
1. Inside this last created folder, executes the command `ssh-keygen -f <key-pair> -m PEM -t rsa-sha2-512 -b 4096 -C "<UID>"`, where the `<UID>` is the same as the name of the last 
created folder. Each user can have multiple keys (so we can provide user orchestrated key rotation), so the `<key-pair>` allows an id for the specific key pair you are going to create.
1. Still inside the same folder executes the command `openssl rsa -in <key-pair> -pubout -out <key-pair>.pub.pem`, generating the file that is going to be shared with the server.
1. Remove the file `<key-pair>.pub` since it is not necessary anymore.
1. Copy the content of the file `<key-pair>.pub.pem` and share it with the server. Do not share the file `<key-pair>`!

### Using m2mams CLI

You can find the CLI documentation [here](https://github.com/flsusp/m2mams-cli).

Using the CLI to generate a key pair is simple like executing the given command:

```shell
m2mams generate my-user-id@company.com
```

This is going to generate the keys bellow:

```
~/.m2mams/my-user-id@company.com/is_rsa
~/.m2mams/my-user-id@company.com/is_rsa.pub.pem
```

In this case you should copy the content of the file `~/.m2mams/my-user-id@company.com/is_rsa.pub.pem` and share it with the server.

## Architecture

The solution is based on 2 key components that interact to provide the capabilities of generating a signature and verifying this signature. The process of sending messages
from client to server is not part of the scope of this project, since any HTTP Client lib that supports HTTPS can be used to achieve this.

### Private Key Provider [CLIENT]

The private key provider is responsible to load and parde the correct private key that should be used by the Signer to generate the signature that should be sent to the server.
The are basically to implementations of private key providers:

* Local File System
* Environment Variable

The client libs should always provide both implementations.

### Signer [CLIENT]

The signer uses a private key to sign the message, generating a [JWT](https://jwt.io/) token as output. This JWT token contains some important claims:

* `uid`: The user identity used to generate the key.
* `kp`: The `<key-pair>` name used for signing the message.

With this claims, the verifier can identify exactly which public key to use to verify the signature.

### Verifier [SERVER]

Finally, the verifier, that has access to all the registered public keys and is able to identify which one should be used and use it to verify a given JWT token.
